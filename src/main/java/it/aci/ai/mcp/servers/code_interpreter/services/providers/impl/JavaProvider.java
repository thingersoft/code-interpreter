package it.aci.ai.mcp.servers.code_interpreter.services.providers.impl;

import java.io.IOException;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.springframework.ai.azure.openai.AzureOpenAiChatOptions;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import it.aci.ai.mcp.servers.code_interpreter.services.providers.LanguageProvider;

@Service
public class JavaProvider extends LanguageProvider {
    /**
     * Constructs a JavaProvider with injected ChatModel.
     */
    public JavaProvider(org.springframework.ai.chat.model.ChatModel chatModel) {
        super(chatModel);
    }

    private static final String MAIN_CLASS_NAME = "Main";
    private static final String WRAPPER_PROJECT_VERSION = "1.0-SNAPSHOT";
    private static final String WRAPPER_PROJECT_ARTIFACT_ID = "autogenerated";
    // XML tags constants
    private static final String TAG_MODEL_VERSION = "modelVersion";
    private static final String TAG_GROUP_ID = "groupId";
    private static final String TAG_ARTIFACT_ID = "artifactId";
    private static final String TAG_VERSION = "version";

    @Override
    public String getFromImage() {
        return "maven:3.9.9-eclipse-temurin-21-jammy";
    }

    @Override
    public String getSourceFileName() {
        return MAIN_CLASS_NAME + ".java";
    }

    @Override
    public List<String> getImageInitCommands() {
        return getSetEnvVariablesCommands(Map.of("MAVEN_CONFIG", "/home/" + LanguageProvider.IMAGE_USER + "/.m2"));
    }

    @Override
    public void prepareWorkspace(Path workspace, String sourceCode) throws IOException {
        // replace class name in source code to match source file name
        Pattern p = Pattern.compile("(public\\s+class\\s+)(\\w+)(\\s*\\{)");
        Matcher m = p.matcher(sourceCode);
        if (m.find()) {
            sourceCode = m.replaceFirst("$1" + MAIN_CLASS_NAME + "$3");
        } else {
            throw new IllegalArgumentException("Unable to identify main class in cource code");
        }

        // infer external dependencies
        Set<MavenDependency> dependencies = inferDependencies(sourceCode);
        String pom = generatePomXml(dependencies);

        // write maven project to workspace
        Path sourcePath = Files.createDirectories(workspace.resolve("src/main/java"));
        Files.writeString(sourcePath.resolve(getSourceFileName()), sourceCode, StandardOpenOption.CREATE);
        Files.writeString(workspace.resolve("pom.xml"), pom, StandardOpenOption.CREATE);

    }

    @Override
    public List<String> getPrepareExecutionCommands(Path workspace) {
        // capture maven errors to stderr
        // TODO keep stdout as well for tracing purpose (need to switch to bash)
        return List.of("mvn package | grep '^\\[ERROR\\]' >&2");
    }

    @Override
    public List<String> getExecutionCommands(Path workspace) {
        return List.of("java -jar target/" + WRAPPER_PROJECT_ARTIFACT_ID + "-" + WRAPPER_PROJECT_VERSION
                + "-jar-with-dependencies.jar");
    }

    /**
     * Generates a pom.xml file with the inferred dependencies.
     */
    private static String generatePomXml(Set<MavenDependency> dependencies) {

        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            // Prevent XXE
            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
            factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
            factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
            factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
            factory.setXIncludeAware(false);
            factory.setExpandEntityReferences(false);
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.newDocument();

            Element project = doc.createElement("project");
            project.setAttribute("xmlns", "http://maven.apache.org/POM/4.0.0");
            project.setAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
            project.setAttribute("xsi:schemaLocation",
                    "http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd");
            doc.appendChild(project);

            appendTextElement(doc, project, TAG_MODEL_VERSION, "4.0.0");
            appendTextElement(doc, project, TAG_GROUP_ID, "com.example");
            appendTextElement(doc, project, TAG_ARTIFACT_ID, WRAPPER_PROJECT_ARTIFACT_ID);
            appendTextElement(doc, project, TAG_VERSION, WRAPPER_PROJECT_VERSION);

            Element dependenciesElement = doc.createElement("dependencies");
            project.appendChild(dependenciesElement);

            for (MavenDependency dep : dependencies) {
                Element dependency = doc.createElement("dependency");
                appendTextElement(doc, dependency, TAG_GROUP_ID, dep.groupId());
                appendTextElement(doc, dependency, TAG_ARTIFACT_ID, dep.artifactId());
                appendTextElement(doc, dependency, TAG_VERSION, dep.version());
                appendTextElement(doc, dependency, "type", dep.type());
                dependenciesElement.appendChild(dependency);
            }

            // assembly plugin
            Element goalsElement = doc.createElement("goals");
            appendTextElement(doc, goalsElement, "goal", "single");

            Element manifestElement = doc.createElement("manifest");
            appendTextElement(doc, manifestElement, "mainClass", MAIN_CLASS_NAME);

            Element archiveElement = doc.createElement("archive");
            archiveElement.appendChild(manifestElement);

            Element descriptorRefsElement = doc.createElement("descriptorRefs");
            appendTextElement(doc, descriptorRefsElement, "descriptorRef", "jar-with-dependencies");

            Element configurationElement = doc.createElement("configuration");
            configurationElement.appendChild(archiveElement);
            configurationElement.appendChild(descriptorRefsElement);

            Element executionElement = doc.createElement("execution");
            appendTextElement(doc, executionElement, "phase", "package");
            executionElement.appendChild(goalsElement);
            executionElement.appendChild(configurationElement);

            Element pluginElement = doc.createElement("plugin");
            appendTextElement(doc, pluginElement, TAG_GROUP_ID, "org.apache.maven.plugins");
            appendTextElement(doc, pluginElement, TAG_ARTIFACT_ID, "maven-assembly-plugin");
            appendTextElement(doc, pluginElement, TAG_VERSION, "3.3.0");
            pluginElement
                    .appendChild(doc.createElement("executions"))
                    .appendChild(executionElement);

            project
                    .appendChild(doc.createElement("build"))
                    .appendChild(doc.createElement("plugins"))
                    .appendChild(pluginElement);

            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            // Prevent XXE in transformation
            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
            Transformer transformer = transformerFactory.newTransformer();
            transformer.setOutputProperty("indent", "yes");
            DOMSource source = new DOMSource(doc);
            StringWriter writer = new StringWriter();
            StreamResult result = new StreamResult(writer);
            transformer.transform(source, result);
            return writer.toString();
        } catch (TransformerException | ParserConfigurationException e) {
            throw new RuntimeException(e);
        }

    }

    private static void appendTextElement(Document doc, Element parent, String tag, String text) {
        Element element = doc.createElement(tag);
        element.appendChild(doc.createTextNode(text));
        parent.appendChild(element);
    }

    protected Set<MavenDependency> inferDependencies(String sourceCode) {

        return ChatClient.create(chatModel)
                .prompt()
                .user(u -> u
                        .text("Infer the dependencies that need to be externally retrieved in order to run the following code:\n ```\n{sourceCode}\n```")
                        .param("sourceCode", sourceCode))
                .options(AzureOpenAiChatOptions.builder()
                        .temperature(0.0)
                        .build())
                .call()
                .entity(new ParameterizedTypeReference<Set<MavenDependency>>() {
                });

    }

    public static record MavenDependency(String groupId, String artifactId, String version, String type) {
    }

}
